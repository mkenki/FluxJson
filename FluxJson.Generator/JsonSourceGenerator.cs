using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;
using FluxJson.Generator; // For SyntaxReceiver
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static FluxJson.Generator.JsonDeserializationGenerator; // For deserialization logic
using static FluxJson.Generator.JsonSerializationGenerator; // For serialization logic

namespace FluxJson.Generator
{
    [Generator]
    public class JsonSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("FJGEN008", "Generator Execute Started", "Generator Execute Started", "FluxJson.Generator", DiagnosticSeverity.Info, true),
                Location.None));

            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("FJGEN009", "SyntaxReceiver is null", "SyntaxReceiver is null", "FluxJson.Generator", DiagnosticSeverity.Error, true),
                    Location.None));
                return;
            }

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                SemanticModel semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                {
                    continue;
                }

                // Check if the class has the [JsonSerializable] attribute
                if (!classSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == "FluxJson.Core.JsonSerializableAttribute"))
                {
                    continue;
                }

                string classNamespace = classSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : classSymbol.ContainingNamespace.ToDisplayString();
                string accessibility = classSymbol.DeclaredAccessibility.ToString().ToLower();

                StringBuilder sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using System.Globalization;");
                sb.AppendLine("using FluxJson;"); // Added for Json class
                sb.AppendLine("using FluxJson.Core;");
                sb.AppendLine("using FluxJson.Core.Configuration;");
                sb.AppendLine();

                if (!string.IsNullOrEmpty(classNamespace))
                {
                    sb.AppendLine($"namespace {classNamespace}");
                    sb.AppendLine("{");
                }

                // Find the IJsonSerializable<T> interface implementation
                INamedTypeSymbol? jsonSerializableInterface = classSymbol.AllInterfaces.FirstOrDefault(i =>
                    i.IsGenericType &&
                    i.ConstructedFrom.ToDisplayString().StartsWith("FluxJson.Core.IJsonSerializable<"));

                if (jsonSerializableInterface == null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("FJGEN010", "Class does not implement IJsonSerializable<T>", $"Class {classSymbol.Name} is marked with [JsonSerializable] but does not implement IJsonSerializable<T>.", "FluxJson.Generator", DiagnosticSeverity.Error, true),
                        Location.None));
                    continue;
                }

                ITypeSymbol genericTypeArgument = jsonSerializableInterface.TypeArguments[0];

                sb.AppendLine($"    {accessibility} partial class {classSymbol.Name} : FluxJson.Core.IJsonSerializable<{genericTypeArgument.ToDisplayString()}>");
                sb.AppendLine("    {");

                JsonSerializationGenerator.GenerateToJsonMethod(sb, classSymbol);
                sb.AppendLine();
                JsonDeserializationGenerator.GenerateFromJsonMethod(sb, classSymbol, genericTypeArgument);

                sb.AppendLine("    }");

                if (!string.IsNullOrEmpty(classNamespace))
                {
                    sb.AppendLine("}");
                }

                context.AddSource($"{classSymbol.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }
    }
}
